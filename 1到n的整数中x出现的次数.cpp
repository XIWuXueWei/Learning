/*
 * @Author: fzy
 * @Date: 2018-12-11 14:59:17
 * @LastEditors: Zhenying
 * @LastEditTime: 2018-12-11 15:33:33
 * @Description: 计算从1到n的整数中，大于等于1小于等于9的数x共出现了多少次。
 */

/*
 * 参考自 http://www.cnblogs.com/nailperry/p/4752987.html
 * 例如1-13中，包含数字1的数有1、10、11、12、13共6次。
 * 求解方法：
 *      这里的X在区间[1,9]中。
 *      首先有以下规律：
 *          1、从1-10，它们的个位数中，任意的X都出现了1次。
 *          2、从1-100，在它们的十位数中，任意的X都出现了10次(即：Xy，y为0-9)。
 *          3、从1-1000，在它们的百位数中，任意的X都出现了100次。
 *      依次类推，从1至10^i，在它们的左数第二位（右数第i位）中，任意的X都出现了10^(i-1)次。
 *      
 *      例子：若n=2593, X=5。从1到2593中，数字5总计出现了813次。其中，259次出现在个位，260次出现在十位，
 *            294次出现在百位，0次出现在千位。
 *              首先个位：从1到2590中，包含了259个10，因此X出现了259次，最后剩余的三个数的个位都比X小，因此不包含X。
 *                         （可以看做，3<X，则个位上可能出现的X的次数仅由更高位决定，等于更高位数字(259)*10^(1-1)=259）
 *              然后十位：从1至2500中，包含了25个100，因此X出现了25*10=250次。当前位的数字为9，大于X,因此会包含10个X。
 *                      总计250+10=260
 *                      （可以看做，9>X，则十位上可能出现的X的次数由更高位和当前位的z个决定，即25*10^(2-1)+1*10^(2-1)=260）
 *              然后百位：从1至2000中，包含了2个1000，因此任意的X都出现了2*100=200次。当前位的数字与X相同，2500-2593共94个
 *                      数包含X。
 *                      （可以看做，X==5，则百位上可能出现X的次数不仅受更高位影响，还受低位影响，等于2*10(3-1)+(93+1)=294）
 *              最后千位，当前位数字小于X，因此不包含X。
 *      总结：
 *          当计算右数第i位包含的X的个数时：
 *              1、取第i位左边的数字(高位)，乘以10^(i-1)，得到基础值a。
 *              2、取第i位数字，计算修正值：
 *                  2.1、如果大于X，则结果为a+10^(i-1)
 *                  2.2、如果小于X，则结果为a
 *                  2.3、如果等于X，则取第i位右边的数字，设为b，最后结果为a+b+1
 */

// 计算代码：

#include <iostream>
#include <vector>
#include <cmath>

using namespace std;

int helper(int n, int x) {
        if(n < 0 || x < 1 || x > 9)
            return 0;
        // high表示位数i之前的数，curr表示位数i上的数；
        // tmp缓存high之后的数，用于计算low和tmp
        // low表示第i位之后的数
        // i表示第i位，从个位开始，即i为1
        int high = n, curr, tmp, low, i = 1;
        int res = 0;
        while (high != 0) {
            high = n / int(pow(10, i));
            tmp = n % int(pow(10, i));
            curr = tmp / int(pow(10, i - 1));
            low = tmp % int(pow(10, i - 1));
            if (curr == x) {
                res += high * pow(10, i - 1) + low + 1;
            } else if (curr < x) {
                res += high * pow(10, i - 1);
            } else {
                res += (high + 1) * pow(10, i - 1);
            }
            i++;
        }
        return res;
}

int main() {
    cout << "res:" << helper(2593, 5) << endl;
    return 1;
}
